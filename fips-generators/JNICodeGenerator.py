
import os

import genutil as util
import yaml

from mod import log
from pycparser import c_parser, c_ast, parse_file

Version = 1
HeaderNote = '/* Machine generated by fips-jni (version {}). Do not edit! */\n\n'.format(Version)

#-------------------------------------------------------------------------------
def jni_type(type_name, is_ptr) :
    
    if is_ptr :
        if type_name == 'char' :
            return 'jstring'

    if type_name == 'int64_t' :
        return 'jlong'
    elif type_name == 'void' :
        return 'void'

    return '<unhandled-type>'

#-------------------------------------------------------------------------------
def java_type(type_name) :

    if type_name == 'char' :
        return 'String'

    if type_name == 'int64_t' :
        return 'long'
    elif type_name == 'void' :
        return 'void'

    return '<unhandled-type>'

#-------------------------------------------------------------------------------
def decl_type(decl, is_jni, is_java) :
    
    # pointer

    is_ptr = type(decl) == c_ast.PtrDecl

    if is_ptr :
        decl = decl.type

    result = ''

    if is_java :
        return java_type(decl.type.names[0])
    elif is_jni :
        return jni_type(decl.type.names[0], is_ptr)
    else :
        for qual in decl.quals :
            result += '{} '.format(qual)
        
        result += decl.type.names[0]

        if is_ptr :
            result += '*'

    return result

#-------------------------------------------------------------------------------
def parse_function_arguments(args, out, is_decl, is_java) :

    first_arg = not is_decl or is_java

    for arg in args :

        if not first_arg :
            out.write(', ')
        else :
            first_arg = False

        if is_decl :
            out.write('{} '.format(decl_type(arg.type, is_decl, is_java)))

        if is_decl :
            out.write(arg.name)
        else :
            out.write('_{}'.format(arg.name))

#-------------------------------------------------------------------------------
def marshal_function_arguments(args, out) :

    for arg in args :

        out.write('\tmarshal_{}({});\n'.format(decl_type(arg.type, True, False), arg.name))

#-------------------------------------------------------------------------------
def cleanup_function_arguments(args, out) :

    for arg in reversed(args) :

        out.write('\tcleanup_{}({});\n'.format(decl_type(arg.type, True, False), arg.name))

#-------------------------------------------------------------------------------
def parse_function_declaration(func_name, func_decl, src, hdr, java, class_prefix) :

    # return type

    return_type = func_decl.type.type.names[0]

    if return_type == 'void' :
        has_return_type = False
    else:
        has_return_type = True

    # write function implementation

    src.write('JNIEXPORT {} JNICALL Java_{}_{}(\n\t'.format(jni_type(return_type, False), class_prefix, func_name))
    src.write('JNIEnv* env, jclass clazz')

    parse_function_arguments(func_decl.args.params, src, True, False)

    src.write(')\n{\n')

    marshal_function_arguments(func_decl.args.params, src)

    src.write('\t')

    if has_return_type :
        src.write('{} _result = '.format(return_type))

    src.write('{}('.format(func_name))

    parse_function_arguments(func_decl.args.params, src, False, False)

    src.write(');\n')

    cleanup_function_arguments(func_decl.args.params, src)

    if has_return_type :
        src.write('\treturn return_{}(_result);\n'.format(jni_type(return_type, False)))

    src.write('}\n\n')

    # write function declaration

    hdr.write('JNIEXPORT {} JNICALL Java_{}_{}(\n\t'.format(jni_type(return_type, False), class_prefix, func_name))
    hdr.write('JNIEnv* env, jclass clazz')

    parse_function_arguments(func_decl.args.params, hdr, True, False)

    hdr.write(');\n\n')

    # write java native declaration

    java.write('\tpublic static native {} {}('.format(java_type(return_type), func_name))

    parse_function_arguments(func_decl.args.params, java, True, True)

    java.write(');\n')

#-------------------------------------------------------------------------------
def generate_source(path, jni_class_name, header_file) :
    src = open(path + '/' + jni_class_name + '.cc', 'w')
    src.write(HeaderNote)
    src.write('#include \"{}.h\"\n\n'.format(jni_class_name))
    src.write('#include \"{}\"\n'.format(os.path.basename(header_file)))
    src.write('#include <jni_marshal.h>\n\n'.format(os.path.basename(header_file)))
    return src

#-------------------------------------------------------------------------------
def generate_header(path, jni_class_name, class_prefix) :
    hdr = open(path + '/' + jni_class_name + '.h', 'w')
    hdr.write(HeaderNote)
    hdr.write('#ifndef _{}_h\n'.format(class_prefix))
    hdr.write('#define _{}_h\n\n'.format(class_prefix))
    hdr.write('#include <jni.h>\n\n')
    hdr.write('#ifdef __cplusplus\nextern "C"\n{\n#endif\n\n')
    return hdr

#-------------------------------------------------------------------------------
def complete_header(hdr) :
    hdr.write('#ifdef __cplusplus\n}\n#endif\n\n#endif\n')

#-------------------------------------------------------------------------------
def generate_java_path(output_root, output_path) :
    if os.path.exists(output_root) :
        try :
            os.makedirs(os.path.dirname(output_path))
        except OSError :
            pass

#-------------------------------------------------------------------------------
def generate_java(output_path, class_name) :
    
    class_package_and_name = class_name.rsplit('.', 1)

    java = open(output_path, 'w')
    java.write('package {};\n\n'.format(class_package_and_name[0]))
    java.write(HeaderNote)
    java.write('public class {} {{\n'.format(class_package_and_name[1]))

    return java

#-------------------------------------------------------------------------------
def complete_java(java) :
    java.write('}\n')

#-------------------------------------------------------------------------------
def generate(input, out_src, out_hdr) :

    if util.isDirty(Version, [input], [out_src, out_hdr]) :

        # read YAML
        with open(input, 'r') as f :
            desc = yaml.load(f)

        # path of YAML - this is where the C header files are searched
        header_path = os.path.dirname(input)

        # output path - in 'fips-deploy/...'' for OUT_OF_SOURCE generation
        output_path = os.path.dirname(out_src)

        # Java output root, relative to path of YAML
        java_class_out = os.path.normpath(os.path.join(header_path, desc['class-output']))

        # generator output file, for 'Unity' build
        out = open(out_src, 'w')
        out.write(HeaderNote)

        # iterate entries
        for header in desc['headers'] :

            # C header file
            header_file = os.path.join(header_path, header['source'])

            # Java package and class name
            java_class_name = header['class']

            # .java output path
            java_class_path = os.path.normpath(os.path.join(java_class_out, java_class_name.replace('.', '/') + '.java'))

            # TODO: dirty file check

            # JNI function names prefix
            jni_class_prefix = java_class_name.replace('.', '_')

            # status message
            print('Generating \'{}\' for \'{}\' ...'.format(java_class_name, header['source']))

            # .cc and .h
            src = generate_source(output_path, java_class_name, header_file)
            hdr = generate_header(output_path, java_class_name, jni_class_prefix)

            # Java directory structure (if needed)
            generate_java_path(java_class_out, java_class_path)
            # .java
            java = generate_java(java_class_path, java_class_name)

            # parse C header
            # TODO: OSX/Linux
            ast = parse_file(header_file, use_cpp=True, cpp_path='cl', cpp_args=['/EP'])

            #ast.show()

            for ext in ast.ext :
                decl_type = type(ext.type)
                if decl_type == c_ast.FuncDecl :
                    parse_function_declaration(ext.name, ext.type, src, hdr, java, jni_class_prefix)

            complete_header(hdr)
            complete_java(java)

            # write generator source file
            out.write('#include "{}.cc"\n'.format(java_class_name))
